#!/usr/bin/env node

/**
 * Automated Error Checking System for ras-UI Design System
 * Proactively monitors TypeScript, ESLint, build errors, and IDE diagnostics
 */

import { execSync } from 'child_process';
import { existsSync, readFileSync } from 'fs';
import { join } from 'path';

const COLORS = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  reset: '\x1b[0m',
  bold: '\x1b[1m'
};

class ErrorChecker {
  constructor() {
    this.errors = [];
    this.warnings = [];
    this.packages = ['packages/react', 'packages/tokens', 'apps/showcase'];
    this.startTime = Date.now();
  }

  log(message, color = 'white') {
    console.log(`${COLORS[color]}${message}${COLORS.reset}`);
  }

  logSection(title) {
    console.log(`\n${COLORS.bold}${COLORS.cyan}=== ${title} ===${COLORS.reset}`);
  }

  async runCommand(command, options = {}) {
    try {
      const result = execSync(command, { 
        encoding: 'utf8', 
        cwd: options.cwd || process.cwd(),
        stdio: options.silent ? 'pipe' : 'inherit'
      });
      return { success: true, output: result };
    } catch (error) {
      return { 
        success: false, 
        output: error.stdout || error.message,
        error: error.stderr || error.message
      };
    }
  }

  async checkTypeScript() {
    this.logSection('TypeScript Compilation Check');
    
    // Check root TypeScript build
    const rootCheck = await this.runCommand('pnpm type-check', { silent: true });
    if (!rootCheck.success) {
      this.errors.push({
        type: 'TypeScript',
        package: 'root',
        message: 'Root TypeScript compilation failed',
        details: rootCheck.error
      });
      this.log('âŒ Root TypeScript errors found', 'red');
    } else {
      this.log('âœ… Root TypeScript compilation clean', 'green');
    }

    // Check individual packages
    for (const pkg of this.packages) {
      if (existsSync(join(pkg, 'tsconfig.json'))) {
        const result = await this.runCommand(`npx tsc --noEmit`, { 
          cwd: pkg, 
          silent: true 
        });
        
        if (!result.success) {
          this.errors.push({
            type: 'TypeScript',
            package: pkg,
            message: `TypeScript errors in ${pkg}`,
            details: result.error
          });
          this.log(`âŒ ${pkg}: TypeScript errors`, 'red');
        } else {
          this.log(`âœ… ${pkg}: TypeScript clean`, 'green');
        }
      }
    }
  }

  async checkESLint() {
    this.logSection('ESLint Analysis');
    
    // Check for ESLint report file (generated by ESLint MCP)
    const eslintReportPath = 'packages/react/eslint-report.json';
    if (existsSync(eslintReportPath)) {
      try {
        const report = JSON.parse(readFileSync(eslintReportPath, 'utf8'));
        const errorCount = report.reduce((sum, file) => sum + file.errorCount, 0);
        const warningCount = report.reduce((sum, file) => sum + file.warningCount, 0);
        
        if (errorCount > 0) {
          this.errors.push({
            type: 'ESLint',
            package: 'packages/react',
            message: `${errorCount} ESLint errors found`,
            details: `${errorCount} errors, ${warningCount} warnings`
          });
          this.log(`âŒ packages/react: ${errorCount} ESLint errors`, 'red');
        } else {
          this.log(`âœ… packages/react: ESLint clean (${warningCount} warnings)`, 'green');
        }
      } catch (e) {
        this.warnings.push({
          type: 'ESLint',
          message: 'Could not parse ESLint report',
          details: e.message
        });
      }
    }

    // Run ESLint on critical packages
    const lintResult = await this.runCommand('pnpm lint', { silent: true });
    if (!lintResult.success) {
      // Try to extract error count from output
      const text = `${lintResult.output || ''}\n${lintResult.error || ''}`;
      const matchErrs = text.match(/(\d+)\s+errors?/i) || text.match(/problems\s*\((\d+)\s*errors?/i);
      const errorCount = matchErrs ? matchErrs[1] : 'unknown';

      this.errors.push({
        type: 'ESLint',
        package: 'workspace',
        message: `Workspace ESLint check failed`,
        details: `${errorCount} errors detected`
      });
      this.log(`âŒ Workspace: ESLint errors detected`, 'red');
    } else {
      this.log('âœ… Workspace: ESLint clean', 'green');
    }
  }

  async checkBuild() {
    this.logSection('Build Integrity Check');
    
    // Check if critical dist files exist
    const criticalFiles = [
      'packages/tokens/dist/tokens.css',
      'packages/tokens/dist/brands.css',
      'packages/react/dist/index.js'
    ];
    
    let missingFiles = [];
    for (const file of criticalFiles) {
      if (!existsSync(file)) {
        missingFiles.push(file);
      }
    }
    
    if (missingFiles.length > 0) {
      this.errors.push({
        type: 'Build',
        package: 'workspace',
        message: 'Critical build artifacts missing',
        details: `Missing: ${missingFiles.join(', ')}`
      });
      this.log('âŒ Build artifacts missing', 'red');
    } else {
      this.log('âœ… Build artifacts present', 'green');
    }

    // Test build process
    const buildResult = await this.runCommand('pnpm build', { silent: true });
    if (!buildResult.success) {
      this.errors.push({
        type: 'Build',
        package: 'workspace',
        message: 'Build process failed',
        details: buildResult.error
      });
      this.log('âŒ Build process failed', 'red');
    } else {
      this.log('âœ… Build process successful', 'green');
    }
  }

  async checkDesignTokens() {
    this.logSection('Design Token Validation');
    
    // Check if Style Dictionary can build tokens
    const tokensResult = await this.runCommand('npm run build:all', { 
      cwd: 'packages/tokens',
      silent: true 
    });
    
    if (!tokensResult.success) {
      this.errors.push({
        type: 'Design Tokens',
        package: 'packages/tokens',
        message: 'Style Dictionary build failed',
        details: tokensResult.error
      });
      this.log('âŒ Design token build failed', 'red');
    } else {
      this.log('âœ… Design tokens build successfully', 'green');
    }

    // Check for required brand files
    const requiredBrandFiles = [
      'packages/tokens/dist/brands/default/tokens.css',
      'packages/tokens/dist/brands/vibrant/tokens.css',
      'packages/tokens/dist/brands/corporate/tokens.css'
    ];
    
    const missingBrands = requiredBrandFiles.filter(file => !existsSync(file));
    if (missingBrands.length > 0) {
      this.errors.push({
        type: 'Design Tokens',
        package: 'packages/tokens',
        message: 'Brand-specific token files missing',
        details: `Missing: ${missingBrands.join(', ')}`
      });
      this.log('âŒ Brand token files missing', 'red');
    } else {
      this.log('âœ… All brand tokens generated', 'green');
    }
  }

  async generateReport() {
    this.logSection('Error Report Summary');
    
    const duration = Date.now() - this.startTime;
    this.log(`Check completed in ${duration}ms`, 'cyan');
    
    if (this.errors.length === 0) {
      this.log('\nðŸŽ‰ No critical errors detected!', 'green');
      if (this.warnings.length > 0) {
        this.log(`âš ï¸  ${this.warnings.length} warnings found`, 'yellow');
      }
      return true;
    }

    this.log(`\nâŒ Found ${this.errors.length} critical errors:`, 'red');
    
    // Group errors by type
    const errorsByType = {};
    this.errors.forEach(error => {
      if (!errorsByType[error.type]) {
        errorsByType[error.type] = [];
      }
      errorsByType[error.type].push(error);
    });

    Object.entries(errorsByType).forEach(([type, errors]) => {
      this.log(`\n${COLORS.bold}${type} Errors (${errors.length}):${COLORS.reset}`, 'red');
      errors.forEach((error, index) => {
        this.log(`  ${index + 1}. ${error.package}: ${error.message}`, 'white');
        if (error.details) {
          this.log(`     Details: ${error.details}`, 'yellow');
        }
      });
    });

    // Provide fix suggestions
    this.log('\nðŸ”§ Suggested Actions:', 'magenta');
    if (errorsByType['TypeScript']) {
      this.log('  â€¢ Run `pnpm type-check` to see TypeScript errors', 'white');
    }
    if (errorsByType['ESLint']) {
      this.log('  â€¢ Run `pnpm lint:fix` to auto-fix ESLint issues (or `pnpm lint -- --fix`)', 'white');
    }
    if (errorsByType['Build']) {
      this.log('  â€¢ Run `pnpm build` to rebuild packages', 'white');
    }
    if (errorsByType['Design Tokens']) {
      this.log('  â€¢ Run `pnpm tokens:all` to rebuild design tokens', 'white');
    }

    return false;
  }

  async run() {
    this.log('ðŸ” Starting automated error checking for ras-UI Design System...', 'cyan');
    
    await this.checkTypeScript();
    await this.checkESLint();
    await this.checkBuild();
    await this.checkDesignTokens();
    
    const success = await this.generateReport();
    process.exit(success ? 0 : 1);
  }
}

// Run the error checker
const checker = new ErrorChecker();
checker.run().catch(error => {
  console.error(`${COLORS.red}Error checker failed:${COLORS.reset}`, error);
  process.exit(1);
});
